#include "mask.h"
#include <iostream>
#include <opencv2/opencv.hpp>
#include <algorithm>
#include <fstream>

using namespace line;

Mask::Mask(const cv::Mat *img) {
    horizontal = img->clone();
    vertical = img->clone();

    /* Morphological transoformations -- Erosion and dilation
     * https://docs.opencv.org/2.4/doc/tutorials/imgproc/erosion_dilatation/erosion_dilatation.html#morphology-1
     */

    //Horizontal
    int horizontalSize = horizontal.cols / SCALE;
    cv::Mat horizontalStructure = cv::getStructuringElement(cv::MORPH_RECT, cv::Size(horizontalSize, 1));
    erode(horizontal, horizontal, horizontalStructure, cv::Point(-1, -1));
    dilate(horizontal, horizontal, horizontalStructure, cv::Point(-1, -1));

    //Vertical
    int verticalSize = vertical.cols / SCALE;
    cv::Mat verticalStructure = cv::getStructuringElement(cv::MORPH_RECT, cv::Size(1, verticalSize));
    erode(vertical, vertical, verticalStructure, cv::Point(-1, -1));
    dilate(vertical, vertical, verticalStructure, cv::Point(-1, -1));

    std::vector<int> compression_params;
    compression_params.push_back(cv::IMWRITE_PNG_COMPRESSION);
    compression_params.push_back(9);

    cv::imwrite("V.png", vertical, compression_params);
    cv::imwrite("H.png", horizontal, compression_params);
    //output can checked using the "V.png" and "H.png" files in this dir

    horizontal = cv::imread("H.png");
    vertical = cv::imread("V.png");

    //Creating a mask of table
    mask = horizontal + vertical;
    mask_points = horizontal & vertical;
    cv::imwrite("mask.png",mask,compression_params);
    cv::imwrite("maskpoints.png",mask_points,compression_params);

    //Intersection points (joints)
    // bitwise_and(horizontal, vertical, joints);
};

Point Mask::mean(cv::Mat *img, int *x, int *y, int val) {
    //*x =  referebnce to initial x value (top left corner of pool window)
    //*y =  reference to intial y value (top left corner of pool window)
    int r = *x;
    int c = *y;
    int X = 0;
    int Y = 0;
    int count = 0;

    //boundary conditions on rows and columns
    while (r - *x < POOL_SIZE && r < img->rows) {
        c = *y;
        while (c - *y < POOL_SIZE && c < img->cols) {

            // "img->at<cv::Vec3b>(r,c) returns an 3 sized array of RGB values,
            // since image is grayscaled and binary, all 3 values will be same
            // "val" is the value that we are looking for -- Black = 0;
            //                                            -- White = 255;
            //
            // adding all the matched pixels coordinates relative to inital coordinates
            if ((int) (img->at<cv::Vec3b>(r, c)[0]) == val) {
                X += r - *x;
                Y += c - *y;
                count++;
            }
            c++;
        }
        r++;
    }
    //check for 0 count to avoid Segmentation Fault
    if (count != 0) {
        //computing mean of targeted region(either white or black)
        X = X / count + *x;
        Y = Y / count + *y;
    } else {
        //0 count implies mean at center
        X = *x + POOL_SIZE / 2;
        Y = *y + POOL_SIZE / 2;
    }
    return Point(X, Y);
}

void Mask::calibrate(cv::Mat *img, int *x, int *y, int val) {
    // calculate mean for target region
    // target region:
    //   if(val == 255) => white
    //   if(val == 0) => black
    Point P = mean(img, x, y, val);

    // cout<<2<<',';
    //compute distance from center to target region mean
    int distsq = (*x + POOL_SIZE / 2 - P.x) * (*x + POOL_SIZE / 2 - P.x) +
                 (*y + POOL_SIZE / 2 - P.y) * (*y + POOL_SIZE / 2 - P.y);
    if (distsq <= 2) return; // if distance is less than or equal to square_root(2),
    // the pool window has been calibrated

    // move left/right and/or up/down to calibrate so that target region mean is as close as possible to center
    if (abs(P.x - (*x + POOL_SIZE / 2)) > 0) *x += ((P.x - (*x + POOL_SIZE / 2)) > 0 ? 1 : -1);
    if (abs(P.y - (*y + POOL_SIZE / 2)) > 0) *y += ((P.y - (*y + POOL_SIZE / 2)) > 0 ? 1 : -1);
    return calibrate(img, x, y, val);
}

static bool compare_line(Line A, Line B) {

    // const static int POOL_SIZE = 5;
    // const static int BUFFER_CAPACITY = 3;

    return (abs(A.start.y - B.start.y) < POOL_SIZE * BUFFER_CAPACITY / 2)
           ? (A.start.x < B.start.x) : (A.start.y < B.start.y);
}


/* Matrix Orientation direction
 *          --------> Y
 *          |
 *          |
 *          |
 *          v
 *          X
 */


// a util function to clean the output generated by "Mask::lines"
// IMPORTANT: This function is written such that it can clean an array of vertical lines
// for horizontal lines, horizontal image has been transposed, and then the computations are done.
// and then the points are transposed again to get correct values
void Mask::clean_list(std::vector<Line> *lines, std::vector<Line>* filtered_lines) {
    bool last = false;
    // cout<<3<<',';
    int diff_threshold = BUFFER_CAPACITY * POOL_SIZE; //threshold defined as required
    //minimum height of cell

    // a util array so as to maintain what all lines need to be merged
    std::vector<Line> temp;

    for (auto i = lines->begin(); i < lines->end(); ++i) {
        // "i" corresponds to reference to ith line( starting from 0)

        // boundary condition for the last line
        // code almost same as below
        if (i == lines->end() - 1) {
            //the last line
            if (last) {
                temp.push_back(*i);
                int x1 = temp[0].start.x;
                int x2 = temp[0].end.x;
                int y = 0;
                auto n = static_cast<int>(temp.size());

                while (!temp.empty()) {
                    x1 = (x1 > temp.front().start.x) ? temp.front().start.x : x1;
                    x2 = (x2 < temp.front().end.x) ? temp.front().end.x : x2;
                    y += temp.front().start.y + temp.front().end.y;
                    temp.erase(temp.begin());
                }
                y = y / (2 * n);

                filtered_lines->emplace_back(Point(x1, y), Point(x2, y));
            } else filtered_lines->push_back(*i);
            break;
        }

        // difference between avg(avg of start and end points) Y coordinate
        // so as to get horizontal difference
        int y_diff = ((i + 1)->start.y + (i + 1)->end.y)
                     - ((i)->start.y + (i)->end.y);
        y_diff /= 2;

        // gap between the starting point of next line and ending point of previous line
        int x_diff = (i + 1)->start.x - (i)->end.x;

        // check for cell gap between lines
        // gap exceeds the threshold in any direction, this means a cell is present
        // merge all the lines that were present before this in the temp array
        if (x_diff > diff_threshold || y_diff > diff_threshold / 2) {
            last = false;
            if (!temp.empty()) {
                temp.push_back(*i);
                int x1 = temp[0].start.x;
                int x2 = temp[0].end.x;
                int y = 0;
                auto n = static_cast<int>(temp.size());

                //merging all the lines, finding out extreme x coordinates,
                //and averaging out y coordinates
                while (!temp.empty()) {
                    x1 = (x1 > temp.front().start.x) ? temp.front().start.x : x1;
                    x2 = (x2 < temp.front().end.x) ? temp.front().end.x : x2;
                    y += temp.front().start.y + temp.front().end.y;
                    temp.erase(temp.begin());
                }

                y = y / (2 * n);
                // push the new line formed after merging all into final array
                filtered_lines->emplace_back(Point(x1, y), Point(x2, y));

            } else {
                //if temp is already empty, push the current line
                filtered_lines->push_back(*i);
            }
        } else {
            //gap is very less, push the line in temp to merge
            last = true;
            temp.push_back(*i);
        }
    }
    /***Printing results***/
    /*
    for (auto &filtered_line : *filtered_lines) {
        cout << filtered_line.start.x << "," << filtered_line.start.y << "; " <<
             filtered_line.end.x << "," << filtered_line.end.y << std::endl;
    }*/
}


//The main function, where lines are detected
//again, does for only vertical lines
void Mask::lines(cv::Mat *img, std::vector<Line> *lines) {
    // cout<<1<<',';
    // flag to say if line is being considered or not
    bool line = false;
    int rows = img->rows; //total rows
    int cols = img->cols; //total columns

    Point temp;
    Line temp_line;

    for (int j = 0; j < cols; j += POOL_SIZE) {

        //initializing buffer
        int buffer = 0;
        for (int i = 0; i < rows; i += POOL_SIZE) {


            // calibrating the current pool window
            /************/
            calibrate(img, &i, &j, ((line) ? 0 : 255));
            /************/

            // cout<<2<<'('<<i<<','<<j<<')'<<"; ";

            int r = i;
            int pool_count = 0; //stores the count of white of pixels in the pool

            //traversing pool and updating pool count
            while (r - i < POOL_SIZE && r < rows) {
                int c = j;
                while (c - j < POOL_SIZE && c < cols) {
                    pool_count += (int) ((int) img->at<cv::Vec3b>(r, c)[0] == 255); //detect white regions
                    c++;
                }
                r++;
            }

            //for buffer to increment, pool_count should be greater than
            //threshold (=POOL_SIZE (considering 1 pixel wide line as minimum) )
            //for white region, bool line will be false for white region as
            //we do not have line in our traversal
            if (line ^ (pool_count >= POOL_SIZE))
                buffer++;

            //storing the first point where buffer started to fill in
            if (buffer == 1) temp = Point(i, j);
                //boundary condition at image end
            else if (buffer == 0 && (i <= img->rows - 1 && i >= img->rows - 1 - POOL_SIZE && line)) {
                temp = Point(i, j);
            }

            //if buffer crosses it's capacity, congrats, you have found the starting/ending point as per requirement
            if ((buffer >= BUFFER_CAPACITY) || (i <= img->rows - 1 && i >= img->rows - 1 - POOL_SIZE && line)) {
                //flip bool expression
                line = !line;
                buffer = 0;

                // if line is true, means the line has just started
                // initialize a temp line
                if (line)
                    temp_line = Line(temp);
                    //else if line is false, line has just ended
                    //give the value of end off temp_line, and push the line computed in the array
                else {
                    temp_line.end = temp;
                    lines->push_back(temp_line);
                }
            }
        }
    }

    //sort the lines such that it will be easier to clean the outpue using Mask::clean_lines
    std::sort(lines->begin(), lines->end(), compare_line);
}


//the driver function for this module
void Mask::extract_borders() {
    //store uncleanded output
    std::vector<Line> Vlines;
    std::vector<Line> Hlines;

    //store cleaned/filtered output
    std::vector<Line> FVlines;
    std::vector<Line> FHlines;

    cv::Mat horizontal_tp;
    //transpose the image so as to use the same functions as used for vertical lines
    cv::transpose(horizontal, horizontal_tp);

    // cout<<"\nSTART\n"<<endl;

    lines(&vertical, &Vlines);
    lines(&horizontal_tp, &Hlines);

    //cout<<4<<',';
    /*****Printing uncleaned output*****/

    std::ofstream fout;
    fout.open("output.csv");
    fout<<"Initial Vertical lines Coordinates\n";
    fout<<"Starting x, Starting y, End x, End y \n";
    std::cout<<"----vert----"<<std::endl;
    for(Line l : Vlines){
        std::cout<<l.start.x<<","<<l.start.y<<";  "<<l.end.x<<","<<l.end.y<<std::endl;
        fout<<l.start.x<<","<<l.start.y<<","<<l.end.x<<","<<l.end.y<<"\n";
    }
    std::cout<<"------------"<<std::endl;


    //cleaning both the lists
    clean_list(&Hlines, &FHlines);
    clean_list(&Vlines, &FVlines);


    //Swap points in case of Horizontal Lines
    //because the image was transposed earlier
    int tmp;
    for (int l=0;l<FHlines.size();l++) {
        // Swapping the x cordinates and y conrdinates as transpose is there
        
        tmp= FHlines[l].start.x;
        FHlines[l].start.x=FHlines[l].start.y;
        FHlines[l].start.y=tmp;

        tmp= FHlines[l].end.x;
        FHlines[l].end.x=FHlines[l].end.y;
        FHlines[l].end.y=tmp;        
        
    }

    /****Final output**/

    std::cout<<"---final----"<<std::endl;
    fout<<"\nFinal Coordinates\n";
    std::cout<<"----horizontal----"<<std::endl;
    fout<<"Horizontal Lines\n";
    fout<<"Starting x, Starting y, Ending x, Ending y \n";
    for(Line l : FHlines){
        std::cout<<l.start.x<<","<<l.start.y<<";  "<<l.end.x<<","<<l.end.y<<std::endl;
        fout<<l.start.x<<","<<l.start.y<<","<<l.end.x<<","<<l.end.y<<"\n";
    }
    std::cout<<"-----------------"<<std::endl;

    fout<<"\nVertical Lines\n";
    fout<<"Starting x, Starting y, Ending x, Ending y \n";
    std::cout<<"----vertical-----"<<std::endl;
    for(Line l : FVlines){
        std::cout<<l.start.x<<","<<l.start.y<<";  "<<l.end.x<<","<<l.end.y<<std::endl;
        fout<<l.start.x<<","<<l.start.y<<","<<l.end.x<<","<<l.end.y<<"\n";
    }
    fout.close();
    std::cout<<"------------"<<std::endl;
    std::cout<<"------------"<<std::endl;

}
